// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/nherson/psc/api/ent/event"
	"github.com/nherson/psc/api/ent/fight"
	"github.com/nherson/psc/api/ent/fighter"
	"github.com/nherson/psc/api/ent/fighteralias"
	"github.com/nherson/psc/api/ent/fighterresults"
	"github.com/nherson/psc/api/ent/predicate"
	"github.com/nherson/psc/api/ent/upcomingevent"
	"github.com/nherson/psc/api/ent/upcomingfight"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEvent          = "Event"
	TypeFight          = "Fight"
	TypeFighter        = "Fighter"
	TypeFighterAlias   = "FighterAlias"
	TypeFighterResults = "FighterResults"
	TypeUpcomingEvent  = "UpcomingEvent"
	TypeUpcomingFight  = "UpcomingFight"
)

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	ufc_event_id  *string
	name          *string
	date          *time.Time
	clearedFields map[string]struct{}
	fights        map[int]struct{}
	removedfights map[int]struct{}
	clearedfights bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUfcEventID sets the "ufc_event_id" field.
func (m *EventMutation) SetUfcEventID(s string) {
	m.ufc_event_id = &s
}

// UfcEventID returns the value of the "ufc_event_id" field in the mutation.
func (m *EventMutation) UfcEventID() (r string, exists bool) {
	v := m.ufc_event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUfcEventID returns the old "ufc_event_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUfcEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUfcEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUfcEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUfcEventID: %w", err)
	}
	return oldValue.UfcEventID, nil
}

// ResetUfcEventID resets all changes to the "ufc_event_id" field.
func (m *EventMutation) ResetUfcEventID() {
	m.ufc_event_id = nil
}

// SetName sets the "name" field.
func (m *EventMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EventMutation) ResetName() {
	m.name = nil
}

// SetDate sets the "date" field.
func (m *EventMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EventMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *EventMutation) ClearDate() {
	m.date = nil
	m.clearedFields[event.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *EventMutation) DateCleared() bool {
	_, ok := m.clearedFields[event.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *EventMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, event.FieldDate)
}

// AddFightIDs adds the "fights" edge to the Fight entity by ids.
func (m *EventMutation) AddFightIDs(ids ...int) {
	if m.fights == nil {
		m.fights = make(map[int]struct{})
	}
	for i := range ids {
		m.fights[ids[i]] = struct{}{}
	}
}

// ClearFights clears the "fights" edge to the Fight entity.
func (m *EventMutation) ClearFights() {
	m.clearedfights = true
}

// FightsCleared reports if the "fights" edge to the Fight entity was cleared.
func (m *EventMutation) FightsCleared() bool {
	return m.clearedfights
}

// RemoveFightIDs removes the "fights" edge to the Fight entity by IDs.
func (m *EventMutation) RemoveFightIDs(ids ...int) {
	if m.removedfights == nil {
		m.removedfights = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fights, ids[i])
		m.removedfights[ids[i]] = struct{}{}
	}
}

// RemovedFights returns the removed IDs of the "fights" edge to the Fight entity.
func (m *EventMutation) RemovedFightsIDs() (ids []int) {
	for id := range m.removedfights {
		ids = append(ids, id)
	}
	return
}

// FightsIDs returns the "fights" edge IDs in the mutation.
func (m *EventMutation) FightsIDs() (ids []int) {
	for id := range m.fights {
		ids = append(ids, id)
	}
	return
}

// ResetFights resets all changes to the "fights" edge.
func (m *EventMutation) ResetFights() {
	m.fights = nil
	m.clearedfights = false
	m.removedfights = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.ufc_event_id != nil {
		fields = append(fields, event.FieldUfcEventID)
	}
	if m.name != nil {
		fields = append(fields, event.FieldName)
	}
	if m.date != nil {
		fields = append(fields, event.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldUfcEventID:
		return m.UfcEventID()
	case event.FieldName:
		return m.Name()
	case event.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldUfcEventID:
		return m.OldUfcEventID(ctx)
	case event.FieldName:
		return m.OldName(ctx)
	case event.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldUfcEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUfcEventID(v)
		return nil
	case event.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case event.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDate) {
		fields = append(fields, event.FieldDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDate:
		m.ClearDate()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldUfcEventID:
		m.ResetUfcEventID()
		return nil
	case event.FieldName:
		m.ResetName()
		return nil
	case event.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fights != nil {
		edges = append(edges, event.EdgeFights)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeFights:
		ids := make([]ent.Value, 0, len(m.fights))
		for id := range m.fights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfights != nil {
		edges = append(edges, event.EdgeFights)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeFights:
		ids := make([]ent.Value, 0, len(m.removedfights))
		for id := range m.removedfights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfights {
		edges = append(edges, event.EdgeFights)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeFights:
		return m.clearedfights
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeFights:
		m.ResetFights()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// FightMutation represents an operation that mutates the Fight nodes in the graph.
type FightMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	updated_at                    *time.Time
	ufc_fight_id                  *string
	card_order                    *int
	addcard_order                 *int
	card_segment                  *string
	result_method                 *string
	result_ending_round           *int
	addresult_ending_round        *int
	result_ending_time_seconds    *int
	addresult_ending_time_seconds *int
	clearedFields                 map[string]struct{}
	event                         *int
	clearedevent                  bool
	fighters                      map[int]struct{}
	removedfighters               map[int]struct{}
	clearedfighters               bool
	fighter_results               map[int]struct{}
	removedfighter_results        map[int]struct{}
	clearedfighter_results        bool
	done                          bool
	oldValue                      func(context.Context) (*Fight, error)
	predicates                    []predicate.Fight
}

var _ ent.Mutation = (*FightMutation)(nil)

// fightOption allows management of the mutation configuration using functional options.
type fightOption func(*FightMutation)

// newFightMutation creates new mutation for the Fight entity.
func newFightMutation(c config, op Op, opts ...fightOption) *FightMutation {
	m := &FightMutation{
		config:        c,
		op:            op,
		typ:           TypeFight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFightID sets the ID field of the mutation.
func withFightID(id int) fightOption {
	return func(m *FightMutation) {
		var (
			err   error
			once  sync.Once
			value *Fight
		)
		m.oldValue = func(ctx context.Context) (*Fight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFight sets the old Fight of the mutation.
func withFight(node *Fight) fightOption {
	return func(m *FightMutation) {
		m.oldValue = func(context.Context) (*Fight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUfcFightID sets the "ufc_fight_id" field.
func (m *FightMutation) SetUfcFightID(s string) {
	m.ufc_fight_id = &s
}

// UfcFightID returns the value of the "ufc_fight_id" field in the mutation.
func (m *FightMutation) UfcFightID() (r string, exists bool) {
	v := m.ufc_fight_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUfcFightID returns the old "ufc_fight_id" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldUfcFightID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUfcFightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUfcFightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUfcFightID: %w", err)
	}
	return oldValue.UfcFightID, nil
}

// ResetUfcFightID resets all changes to the "ufc_fight_id" field.
func (m *FightMutation) ResetUfcFightID() {
	m.ufc_fight_id = nil
}

// SetCardOrder sets the "card_order" field.
func (m *FightMutation) SetCardOrder(i int) {
	m.card_order = &i
	m.addcard_order = nil
}

// CardOrder returns the value of the "card_order" field in the mutation.
func (m *FightMutation) CardOrder() (r int, exists bool) {
	v := m.card_order
	if v == nil {
		return
	}
	return *v, true
}

// OldCardOrder returns the old "card_order" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldCardOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardOrder: %w", err)
	}
	return oldValue.CardOrder, nil
}

// AddCardOrder adds i to the "card_order" field.
func (m *FightMutation) AddCardOrder(i int) {
	if m.addcard_order != nil {
		*m.addcard_order += i
	} else {
		m.addcard_order = &i
	}
}

// AddedCardOrder returns the value that was added to the "card_order" field in this mutation.
func (m *FightMutation) AddedCardOrder() (r int, exists bool) {
	v := m.addcard_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetCardOrder resets all changes to the "card_order" field.
func (m *FightMutation) ResetCardOrder() {
	m.card_order = nil
	m.addcard_order = nil
}

// SetCardSegment sets the "card_segment" field.
func (m *FightMutation) SetCardSegment(s string) {
	m.card_segment = &s
}

// CardSegment returns the value of the "card_segment" field in the mutation.
func (m *FightMutation) CardSegment() (r string, exists bool) {
	v := m.card_segment
	if v == nil {
		return
	}
	return *v, true
}

// OldCardSegment returns the old "card_segment" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldCardSegment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardSegment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardSegment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardSegment: %w", err)
	}
	return oldValue.CardSegment, nil
}

// ResetCardSegment resets all changes to the "card_segment" field.
func (m *FightMutation) ResetCardSegment() {
	m.card_segment = nil
}

// SetResultMethod sets the "result_method" field.
func (m *FightMutation) SetResultMethod(s string) {
	m.result_method = &s
}

// ResultMethod returns the value of the "result_method" field in the mutation.
func (m *FightMutation) ResultMethod() (r string, exists bool) {
	v := m.result_method
	if v == nil {
		return
	}
	return *v, true
}

// OldResultMethod returns the old "result_method" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldResultMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultMethod: %w", err)
	}
	return oldValue.ResultMethod, nil
}

// ResetResultMethod resets all changes to the "result_method" field.
func (m *FightMutation) ResetResultMethod() {
	m.result_method = nil
}

// SetResultEndingRound sets the "result_ending_round" field.
func (m *FightMutation) SetResultEndingRound(i int) {
	m.result_ending_round = &i
	m.addresult_ending_round = nil
}

// ResultEndingRound returns the value of the "result_ending_round" field in the mutation.
func (m *FightMutation) ResultEndingRound() (r int, exists bool) {
	v := m.result_ending_round
	if v == nil {
		return
	}
	return *v, true
}

// OldResultEndingRound returns the old "result_ending_round" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldResultEndingRound(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultEndingRound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultEndingRound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultEndingRound: %w", err)
	}
	return oldValue.ResultEndingRound, nil
}

// AddResultEndingRound adds i to the "result_ending_round" field.
func (m *FightMutation) AddResultEndingRound(i int) {
	if m.addresult_ending_round != nil {
		*m.addresult_ending_round += i
	} else {
		m.addresult_ending_round = &i
	}
}

// AddedResultEndingRound returns the value that was added to the "result_ending_round" field in this mutation.
func (m *FightMutation) AddedResultEndingRound() (r int, exists bool) {
	v := m.addresult_ending_round
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultEndingRound resets all changes to the "result_ending_round" field.
func (m *FightMutation) ResetResultEndingRound() {
	m.result_ending_round = nil
	m.addresult_ending_round = nil
}

// SetResultEndingTimeSeconds sets the "result_ending_time_seconds" field.
func (m *FightMutation) SetResultEndingTimeSeconds(i int) {
	m.result_ending_time_seconds = &i
	m.addresult_ending_time_seconds = nil
}

// ResultEndingTimeSeconds returns the value of the "result_ending_time_seconds" field in the mutation.
func (m *FightMutation) ResultEndingTimeSeconds() (r int, exists bool) {
	v := m.result_ending_time_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldResultEndingTimeSeconds returns the old "result_ending_time_seconds" field's value of the Fight entity.
// If the Fight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FightMutation) OldResultEndingTimeSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultEndingTimeSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultEndingTimeSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultEndingTimeSeconds: %w", err)
	}
	return oldValue.ResultEndingTimeSeconds, nil
}

// AddResultEndingTimeSeconds adds i to the "result_ending_time_seconds" field.
func (m *FightMutation) AddResultEndingTimeSeconds(i int) {
	if m.addresult_ending_time_seconds != nil {
		*m.addresult_ending_time_seconds += i
	} else {
		m.addresult_ending_time_seconds = &i
	}
}

// AddedResultEndingTimeSeconds returns the value that was added to the "result_ending_time_seconds" field in this mutation.
func (m *FightMutation) AddedResultEndingTimeSeconds() (r int, exists bool) {
	v := m.addresult_ending_time_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultEndingTimeSeconds resets all changes to the "result_ending_time_seconds" field.
func (m *FightMutation) ResetResultEndingTimeSeconds() {
	m.result_ending_time_seconds = nil
	m.addresult_ending_time_seconds = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *FightMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *FightMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *FightMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *FightMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *FightMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *FightMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// AddFighterIDs adds the "fighters" edge to the Fighter entity by ids.
func (m *FightMutation) AddFighterIDs(ids ...int) {
	if m.fighters == nil {
		m.fighters = make(map[int]struct{})
	}
	for i := range ids {
		m.fighters[ids[i]] = struct{}{}
	}
}

// ClearFighters clears the "fighters" edge to the Fighter entity.
func (m *FightMutation) ClearFighters() {
	m.clearedfighters = true
}

// FightersCleared reports if the "fighters" edge to the Fighter entity was cleared.
func (m *FightMutation) FightersCleared() bool {
	return m.clearedfighters
}

// RemoveFighterIDs removes the "fighters" edge to the Fighter entity by IDs.
func (m *FightMutation) RemoveFighterIDs(ids ...int) {
	if m.removedfighters == nil {
		m.removedfighters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fighters, ids[i])
		m.removedfighters[ids[i]] = struct{}{}
	}
}

// RemovedFighters returns the removed IDs of the "fighters" edge to the Fighter entity.
func (m *FightMutation) RemovedFightersIDs() (ids []int) {
	for id := range m.removedfighters {
		ids = append(ids, id)
	}
	return
}

// FightersIDs returns the "fighters" edge IDs in the mutation.
func (m *FightMutation) FightersIDs() (ids []int) {
	for id := range m.fighters {
		ids = append(ids, id)
	}
	return
}

// ResetFighters resets all changes to the "fighters" edge.
func (m *FightMutation) ResetFighters() {
	m.fighters = nil
	m.clearedfighters = false
	m.removedfighters = nil
}

// AddFighterResultIDs adds the "fighter_results" edge to the FighterResults entity by ids.
func (m *FightMutation) AddFighterResultIDs(ids ...int) {
	if m.fighter_results == nil {
		m.fighter_results = make(map[int]struct{})
	}
	for i := range ids {
		m.fighter_results[ids[i]] = struct{}{}
	}
}

// ClearFighterResults clears the "fighter_results" edge to the FighterResults entity.
func (m *FightMutation) ClearFighterResults() {
	m.clearedfighter_results = true
}

// FighterResultsCleared reports if the "fighter_results" edge to the FighterResults entity was cleared.
func (m *FightMutation) FighterResultsCleared() bool {
	return m.clearedfighter_results
}

// RemoveFighterResultIDs removes the "fighter_results" edge to the FighterResults entity by IDs.
func (m *FightMutation) RemoveFighterResultIDs(ids ...int) {
	if m.removedfighter_results == nil {
		m.removedfighter_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fighter_results, ids[i])
		m.removedfighter_results[ids[i]] = struct{}{}
	}
}

// RemovedFighterResults returns the removed IDs of the "fighter_results" edge to the FighterResults entity.
func (m *FightMutation) RemovedFighterResultsIDs() (ids []int) {
	for id := range m.removedfighter_results {
		ids = append(ids, id)
	}
	return
}

// FighterResultsIDs returns the "fighter_results" edge IDs in the mutation.
func (m *FightMutation) FighterResultsIDs() (ids []int) {
	for id := range m.fighter_results {
		ids = append(ids, id)
	}
	return
}

// ResetFighterResults resets all changes to the "fighter_results" edge.
func (m *FightMutation) ResetFighterResults() {
	m.fighter_results = nil
	m.clearedfighter_results = false
	m.removedfighter_results = nil
}

// Where appends a list predicates to the FightMutation builder.
func (m *FightMutation) Where(ps ...predicate.Fight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fight).
func (m *FightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FightMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, fight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fight.FieldUpdatedAt)
	}
	if m.ufc_fight_id != nil {
		fields = append(fields, fight.FieldUfcFightID)
	}
	if m.card_order != nil {
		fields = append(fields, fight.FieldCardOrder)
	}
	if m.card_segment != nil {
		fields = append(fields, fight.FieldCardSegment)
	}
	if m.result_method != nil {
		fields = append(fields, fight.FieldResultMethod)
	}
	if m.result_ending_round != nil {
		fields = append(fields, fight.FieldResultEndingRound)
	}
	if m.result_ending_time_seconds != nil {
		fields = append(fields, fight.FieldResultEndingTimeSeconds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fight.FieldCreatedAt:
		return m.CreatedAt()
	case fight.FieldUpdatedAt:
		return m.UpdatedAt()
	case fight.FieldUfcFightID:
		return m.UfcFightID()
	case fight.FieldCardOrder:
		return m.CardOrder()
	case fight.FieldCardSegment:
		return m.CardSegment()
	case fight.FieldResultMethod:
		return m.ResultMethod()
	case fight.FieldResultEndingRound:
		return m.ResultEndingRound()
	case fight.FieldResultEndingTimeSeconds:
		return m.ResultEndingTimeSeconds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fight.FieldUfcFightID:
		return m.OldUfcFightID(ctx)
	case fight.FieldCardOrder:
		return m.OldCardOrder(ctx)
	case fight.FieldCardSegment:
		return m.OldCardSegment(ctx)
	case fight.FieldResultMethod:
		return m.OldResultMethod(ctx)
	case fight.FieldResultEndingRound:
		return m.OldResultEndingRound(ctx)
	case fight.FieldResultEndingTimeSeconds:
		return m.OldResultEndingTimeSeconds(ctx)
	}
	return nil, fmt.Errorf("unknown Fight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fight.FieldUfcFightID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUfcFightID(v)
		return nil
	case fight.FieldCardOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardOrder(v)
		return nil
	case fight.FieldCardSegment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardSegment(v)
		return nil
	case fight.FieldResultMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultMethod(v)
		return nil
	case fight.FieldResultEndingRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultEndingRound(v)
		return nil
	case fight.FieldResultEndingTimeSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultEndingTimeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown Fight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FightMutation) AddedFields() []string {
	var fields []string
	if m.addcard_order != nil {
		fields = append(fields, fight.FieldCardOrder)
	}
	if m.addresult_ending_round != nil {
		fields = append(fields, fight.FieldResultEndingRound)
	}
	if m.addresult_ending_time_seconds != nil {
		fields = append(fields, fight.FieldResultEndingTimeSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fight.FieldCardOrder:
		return m.AddedCardOrder()
	case fight.FieldResultEndingRound:
		return m.AddedResultEndingRound()
	case fight.FieldResultEndingTimeSeconds:
		return m.AddedResultEndingTimeSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fight.FieldCardOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCardOrder(v)
		return nil
	case fight.FieldResultEndingRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultEndingRound(v)
		return nil
	case fight.FieldResultEndingTimeSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultEndingTimeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown Fight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Fight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FightMutation) ResetField(name string) error {
	switch name {
	case fight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fight.FieldUfcFightID:
		m.ResetUfcFightID()
		return nil
	case fight.FieldCardOrder:
		m.ResetCardOrder()
		return nil
	case fight.FieldCardSegment:
		m.ResetCardSegment()
		return nil
	case fight.FieldResultMethod:
		m.ResetResultMethod()
		return nil
	case fight.FieldResultEndingRound:
		m.ResetResultEndingRound()
		return nil
	case fight.FieldResultEndingTimeSeconds:
		m.ResetResultEndingTimeSeconds()
		return nil
	}
	return fmt.Errorf("unknown Fight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FightMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.event != nil {
		edges = append(edges, fight.EdgeEvent)
	}
	if m.fighters != nil {
		edges = append(edges, fight.EdgeFighters)
	}
	if m.fighter_results != nil {
		edges = append(edges, fight.EdgeFighterResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fight.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case fight.EdgeFighters:
		ids := make([]ent.Value, 0, len(m.fighters))
		for id := range m.fighters {
			ids = append(ids, id)
		}
		return ids
	case fight.EdgeFighterResults:
		ids := make([]ent.Value, 0, len(m.fighter_results))
		for id := range m.fighter_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfighters != nil {
		edges = append(edges, fight.EdgeFighters)
	}
	if m.removedfighter_results != nil {
		edges = append(edges, fight.EdgeFighterResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fight.EdgeFighters:
		ids := make([]ent.Value, 0, len(m.removedfighters))
		for id := range m.removedfighters {
			ids = append(ids, id)
		}
		return ids
	case fight.EdgeFighterResults:
		ids := make([]ent.Value, 0, len(m.removedfighter_results))
		for id := range m.removedfighter_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedevent {
		edges = append(edges, fight.EdgeEvent)
	}
	if m.clearedfighters {
		edges = append(edges, fight.EdgeFighters)
	}
	if m.clearedfighter_results {
		edges = append(edges, fight.EdgeFighterResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FightMutation) EdgeCleared(name string) bool {
	switch name {
	case fight.EdgeEvent:
		return m.clearedevent
	case fight.EdgeFighters:
		return m.clearedfighters
	case fight.EdgeFighterResults:
		return m.clearedfighter_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FightMutation) ClearEdge(name string) error {
	switch name {
	case fight.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Fight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FightMutation) ResetEdge(name string) error {
	switch name {
	case fight.EdgeEvent:
		m.ResetEvent()
		return nil
	case fight.EdgeFighters:
		m.ResetFighters()
		return nil
	case fight.EdgeFighterResults:
		m.ResetFighterResults()
		return nil
	}
	return fmt.Errorf("unknown Fight edge %s", name)
}

// FighterMutation represents an operation that mutates the Fighter nodes in the graph.
type FighterMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	ufc_fighter_id         *string
	mma_id                 *int
	addmma_id              *int
	first_name             *string
	last_name              *string
	nick_name              *string
	clearedFields          map[string]struct{}
	fights                 map[int]struct{}
	removedfights          map[int]struct{}
	clearedfights          bool
	fighter_aliases        map[int]struct{}
	removedfighter_aliases map[int]struct{}
	clearedfighter_aliases bool
	fighter_results        map[int]struct{}
	removedfighter_results map[int]struct{}
	clearedfighter_results bool
	done                   bool
	oldValue               func(context.Context) (*Fighter, error)
	predicates             []predicate.Fighter
}

var _ ent.Mutation = (*FighterMutation)(nil)

// fighterOption allows management of the mutation configuration using functional options.
type fighterOption func(*FighterMutation)

// newFighterMutation creates new mutation for the Fighter entity.
func newFighterMutation(c config, op Op, opts ...fighterOption) *FighterMutation {
	m := &FighterMutation{
		config:        c,
		op:            op,
		typ:           TypeFighter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFighterID sets the ID field of the mutation.
func withFighterID(id int) fighterOption {
	return func(m *FighterMutation) {
		var (
			err   error
			once  sync.Once
			value *Fighter
		)
		m.oldValue = func(ctx context.Context) (*Fighter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fighter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFighter sets the old Fighter of the mutation.
func withFighter(node *Fighter) fighterOption {
	return func(m *FighterMutation) {
		m.oldValue = func(context.Context) (*Fighter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FighterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FighterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FighterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FighterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fighter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FighterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FighterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FighterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FighterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FighterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FighterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUfcFighterID sets the "ufc_fighter_id" field.
func (m *FighterMutation) SetUfcFighterID(s string) {
	m.ufc_fighter_id = &s
}

// UfcFighterID returns the value of the "ufc_fighter_id" field in the mutation.
func (m *FighterMutation) UfcFighterID() (r string, exists bool) {
	v := m.ufc_fighter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUfcFighterID returns the old "ufc_fighter_id" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldUfcFighterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUfcFighterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUfcFighterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUfcFighterID: %w", err)
	}
	return oldValue.UfcFighterID, nil
}

// ResetUfcFighterID resets all changes to the "ufc_fighter_id" field.
func (m *FighterMutation) ResetUfcFighterID() {
	m.ufc_fighter_id = nil
}

// SetMmaID sets the "mma_id" field.
func (m *FighterMutation) SetMmaID(i int) {
	m.mma_id = &i
	m.addmma_id = nil
}

// MmaID returns the value of the "mma_id" field in the mutation.
func (m *FighterMutation) MmaID() (r int, exists bool) {
	v := m.mma_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMmaID returns the old "mma_id" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldMmaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMmaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMmaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMmaID: %w", err)
	}
	return oldValue.MmaID, nil
}

// AddMmaID adds i to the "mma_id" field.
func (m *FighterMutation) AddMmaID(i int) {
	if m.addmma_id != nil {
		*m.addmma_id += i
	} else {
		m.addmma_id = &i
	}
}

// AddedMmaID returns the value that was added to the "mma_id" field in this mutation.
func (m *FighterMutation) AddedMmaID() (r int, exists bool) {
	v := m.addmma_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMmaID resets all changes to the "mma_id" field.
func (m *FighterMutation) ResetMmaID() {
	m.mma_id = nil
	m.addmma_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *FighterMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *FighterMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *FighterMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *FighterMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *FighterMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *FighterMutation) ResetLastName() {
	m.last_name = nil
}

// SetNickName sets the "nick_name" field.
func (m *FighterMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *FighterMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the Fighter entity.
// If the Fighter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *FighterMutation) ResetNickName() {
	m.nick_name = nil
}

// AddFightIDs adds the "fights" edge to the Fight entity by ids.
func (m *FighterMutation) AddFightIDs(ids ...int) {
	if m.fights == nil {
		m.fights = make(map[int]struct{})
	}
	for i := range ids {
		m.fights[ids[i]] = struct{}{}
	}
}

// ClearFights clears the "fights" edge to the Fight entity.
func (m *FighterMutation) ClearFights() {
	m.clearedfights = true
}

// FightsCleared reports if the "fights" edge to the Fight entity was cleared.
func (m *FighterMutation) FightsCleared() bool {
	return m.clearedfights
}

// RemoveFightIDs removes the "fights" edge to the Fight entity by IDs.
func (m *FighterMutation) RemoveFightIDs(ids ...int) {
	if m.removedfights == nil {
		m.removedfights = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fights, ids[i])
		m.removedfights[ids[i]] = struct{}{}
	}
}

// RemovedFights returns the removed IDs of the "fights" edge to the Fight entity.
func (m *FighterMutation) RemovedFightsIDs() (ids []int) {
	for id := range m.removedfights {
		ids = append(ids, id)
	}
	return
}

// FightsIDs returns the "fights" edge IDs in the mutation.
func (m *FighterMutation) FightsIDs() (ids []int) {
	for id := range m.fights {
		ids = append(ids, id)
	}
	return
}

// ResetFights resets all changes to the "fights" edge.
func (m *FighterMutation) ResetFights() {
	m.fights = nil
	m.clearedfights = false
	m.removedfights = nil
}

// AddFighterAliasIDs adds the "fighter_aliases" edge to the FighterAlias entity by ids.
func (m *FighterMutation) AddFighterAliasIDs(ids ...int) {
	if m.fighter_aliases == nil {
		m.fighter_aliases = make(map[int]struct{})
	}
	for i := range ids {
		m.fighter_aliases[ids[i]] = struct{}{}
	}
}

// ClearFighterAliases clears the "fighter_aliases" edge to the FighterAlias entity.
func (m *FighterMutation) ClearFighterAliases() {
	m.clearedfighter_aliases = true
}

// FighterAliasesCleared reports if the "fighter_aliases" edge to the FighterAlias entity was cleared.
func (m *FighterMutation) FighterAliasesCleared() bool {
	return m.clearedfighter_aliases
}

// RemoveFighterAliasIDs removes the "fighter_aliases" edge to the FighterAlias entity by IDs.
func (m *FighterMutation) RemoveFighterAliasIDs(ids ...int) {
	if m.removedfighter_aliases == nil {
		m.removedfighter_aliases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fighter_aliases, ids[i])
		m.removedfighter_aliases[ids[i]] = struct{}{}
	}
}

// RemovedFighterAliases returns the removed IDs of the "fighter_aliases" edge to the FighterAlias entity.
func (m *FighterMutation) RemovedFighterAliasesIDs() (ids []int) {
	for id := range m.removedfighter_aliases {
		ids = append(ids, id)
	}
	return
}

// FighterAliasesIDs returns the "fighter_aliases" edge IDs in the mutation.
func (m *FighterMutation) FighterAliasesIDs() (ids []int) {
	for id := range m.fighter_aliases {
		ids = append(ids, id)
	}
	return
}

// ResetFighterAliases resets all changes to the "fighter_aliases" edge.
func (m *FighterMutation) ResetFighterAliases() {
	m.fighter_aliases = nil
	m.clearedfighter_aliases = false
	m.removedfighter_aliases = nil
}

// AddFighterResultIDs adds the "fighter_results" edge to the FighterResults entity by ids.
func (m *FighterMutation) AddFighterResultIDs(ids ...int) {
	if m.fighter_results == nil {
		m.fighter_results = make(map[int]struct{})
	}
	for i := range ids {
		m.fighter_results[ids[i]] = struct{}{}
	}
}

// ClearFighterResults clears the "fighter_results" edge to the FighterResults entity.
func (m *FighterMutation) ClearFighterResults() {
	m.clearedfighter_results = true
}

// FighterResultsCleared reports if the "fighter_results" edge to the FighterResults entity was cleared.
func (m *FighterMutation) FighterResultsCleared() bool {
	return m.clearedfighter_results
}

// RemoveFighterResultIDs removes the "fighter_results" edge to the FighterResults entity by IDs.
func (m *FighterMutation) RemoveFighterResultIDs(ids ...int) {
	if m.removedfighter_results == nil {
		m.removedfighter_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fighter_results, ids[i])
		m.removedfighter_results[ids[i]] = struct{}{}
	}
}

// RemovedFighterResults returns the removed IDs of the "fighter_results" edge to the FighterResults entity.
func (m *FighterMutation) RemovedFighterResultsIDs() (ids []int) {
	for id := range m.removedfighter_results {
		ids = append(ids, id)
	}
	return
}

// FighterResultsIDs returns the "fighter_results" edge IDs in the mutation.
func (m *FighterMutation) FighterResultsIDs() (ids []int) {
	for id := range m.fighter_results {
		ids = append(ids, id)
	}
	return
}

// ResetFighterResults resets all changes to the "fighter_results" edge.
func (m *FighterMutation) ResetFighterResults() {
	m.fighter_results = nil
	m.clearedfighter_results = false
	m.removedfighter_results = nil
}

// Where appends a list predicates to the FighterMutation builder.
func (m *FighterMutation) Where(ps ...predicate.Fighter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FighterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FighterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fighter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FighterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FighterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fighter).
func (m *FighterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FighterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, fighter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fighter.FieldUpdatedAt)
	}
	if m.ufc_fighter_id != nil {
		fields = append(fields, fighter.FieldUfcFighterID)
	}
	if m.mma_id != nil {
		fields = append(fields, fighter.FieldMmaID)
	}
	if m.first_name != nil {
		fields = append(fields, fighter.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, fighter.FieldLastName)
	}
	if m.nick_name != nil {
		fields = append(fields, fighter.FieldNickName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FighterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fighter.FieldCreatedAt:
		return m.CreatedAt()
	case fighter.FieldUpdatedAt:
		return m.UpdatedAt()
	case fighter.FieldUfcFighterID:
		return m.UfcFighterID()
	case fighter.FieldMmaID:
		return m.MmaID()
	case fighter.FieldFirstName:
		return m.FirstName()
	case fighter.FieldLastName:
		return m.LastName()
	case fighter.FieldNickName:
		return m.NickName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FighterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fighter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fighter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fighter.FieldUfcFighterID:
		return m.OldUfcFighterID(ctx)
	case fighter.FieldMmaID:
		return m.OldMmaID(ctx)
	case fighter.FieldFirstName:
		return m.OldFirstName(ctx)
	case fighter.FieldLastName:
		return m.OldLastName(ctx)
	case fighter.FieldNickName:
		return m.OldNickName(ctx)
	}
	return nil, fmt.Errorf("unknown Fighter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fighter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fighter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fighter.FieldUfcFighterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUfcFighterID(v)
		return nil
	case fighter.FieldMmaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMmaID(v)
		return nil
	case fighter.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case fighter.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case fighter.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	}
	return fmt.Errorf("unknown Fighter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FighterMutation) AddedFields() []string {
	var fields []string
	if m.addmma_id != nil {
		fields = append(fields, fighter.FieldMmaID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FighterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fighter.FieldMmaID:
		return m.AddedMmaID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fighter.FieldMmaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMmaID(v)
		return nil
	}
	return fmt.Errorf("unknown Fighter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FighterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FighterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FighterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Fighter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FighterMutation) ResetField(name string) error {
	switch name {
	case fighter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fighter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fighter.FieldUfcFighterID:
		m.ResetUfcFighterID()
		return nil
	case fighter.FieldMmaID:
		m.ResetMmaID()
		return nil
	case fighter.FieldFirstName:
		m.ResetFirstName()
		return nil
	case fighter.FieldLastName:
		m.ResetLastName()
		return nil
	case fighter.FieldNickName:
		m.ResetNickName()
		return nil
	}
	return fmt.Errorf("unknown Fighter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FighterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.fights != nil {
		edges = append(edges, fighter.EdgeFights)
	}
	if m.fighter_aliases != nil {
		edges = append(edges, fighter.EdgeFighterAliases)
	}
	if m.fighter_results != nil {
		edges = append(edges, fighter.EdgeFighterResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FighterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fighter.EdgeFights:
		ids := make([]ent.Value, 0, len(m.fights))
		for id := range m.fights {
			ids = append(ids, id)
		}
		return ids
	case fighter.EdgeFighterAliases:
		ids := make([]ent.Value, 0, len(m.fighter_aliases))
		for id := range m.fighter_aliases {
			ids = append(ids, id)
		}
		return ids
	case fighter.EdgeFighterResults:
		ids := make([]ent.Value, 0, len(m.fighter_results))
		for id := range m.fighter_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FighterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfights != nil {
		edges = append(edges, fighter.EdgeFights)
	}
	if m.removedfighter_aliases != nil {
		edges = append(edges, fighter.EdgeFighterAliases)
	}
	if m.removedfighter_results != nil {
		edges = append(edges, fighter.EdgeFighterResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FighterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fighter.EdgeFights:
		ids := make([]ent.Value, 0, len(m.removedfights))
		for id := range m.removedfights {
			ids = append(ids, id)
		}
		return ids
	case fighter.EdgeFighterAliases:
		ids := make([]ent.Value, 0, len(m.removedfighter_aliases))
		for id := range m.removedfighter_aliases {
			ids = append(ids, id)
		}
		return ids
	case fighter.EdgeFighterResults:
		ids := make([]ent.Value, 0, len(m.removedfighter_results))
		for id := range m.removedfighter_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FighterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfights {
		edges = append(edges, fighter.EdgeFights)
	}
	if m.clearedfighter_aliases {
		edges = append(edges, fighter.EdgeFighterAliases)
	}
	if m.clearedfighter_results {
		edges = append(edges, fighter.EdgeFighterResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FighterMutation) EdgeCleared(name string) bool {
	switch name {
	case fighter.EdgeFights:
		return m.clearedfights
	case fighter.EdgeFighterAliases:
		return m.clearedfighter_aliases
	case fighter.EdgeFighterResults:
		return m.clearedfighter_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FighterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Fighter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FighterMutation) ResetEdge(name string) error {
	switch name {
	case fighter.EdgeFights:
		m.ResetFights()
		return nil
	case fighter.EdgeFighterAliases:
		m.ResetFighterAliases()
		return nil
	case fighter.EdgeFighterResults:
		m.ResetFighterResults()
		return nil
	}
	return fmt.Errorf("unknown Fighter edge %s", name)
}

// FighterAliasMutation represents an operation that mutates the FighterAlias nodes in the graph.
type FighterAliasMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	alias          *string
	clearedFields  map[string]struct{}
	fighter        *int
	clearedfighter bool
	done           bool
	oldValue       func(context.Context) (*FighterAlias, error)
	predicates     []predicate.FighterAlias
}

var _ ent.Mutation = (*FighterAliasMutation)(nil)

// fighteraliasOption allows management of the mutation configuration using functional options.
type fighteraliasOption func(*FighterAliasMutation)

// newFighterAliasMutation creates new mutation for the FighterAlias entity.
func newFighterAliasMutation(c config, op Op, opts ...fighteraliasOption) *FighterAliasMutation {
	m := &FighterAliasMutation{
		config:        c,
		op:            op,
		typ:           TypeFighterAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFighterAliasID sets the ID field of the mutation.
func withFighterAliasID(id int) fighteraliasOption {
	return func(m *FighterAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *FighterAlias
		)
		m.oldValue = func(ctx context.Context) (*FighterAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FighterAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFighterAlias sets the old FighterAlias of the mutation.
func withFighterAlias(node *FighterAlias) fighteraliasOption {
	return func(m *FighterAliasMutation) {
		m.oldValue = func(context.Context) (*FighterAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FighterAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FighterAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FighterAliasMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FighterAliasMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FighterAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FighterAliasMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FighterAliasMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FighterAlias entity.
// If the FighterAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterAliasMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FighterAliasMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FighterAliasMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FighterAliasMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FighterAlias entity.
// If the FighterAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterAliasMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FighterAliasMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAlias sets the "alias" field.
func (m *FighterAliasMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *FighterAliasMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the FighterAlias entity.
// If the FighterAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterAliasMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *FighterAliasMutation) ResetAlias() {
	m.alias = nil
}

// SetFighterID sets the "fighter" edge to the Fighter entity by id.
func (m *FighterAliasMutation) SetFighterID(id int) {
	m.fighter = &id
}

// ClearFighter clears the "fighter" edge to the Fighter entity.
func (m *FighterAliasMutation) ClearFighter() {
	m.clearedfighter = true
}

// FighterCleared reports if the "fighter" edge to the Fighter entity was cleared.
func (m *FighterAliasMutation) FighterCleared() bool {
	return m.clearedfighter
}

// FighterID returns the "fighter" edge ID in the mutation.
func (m *FighterAliasMutation) FighterID() (id int, exists bool) {
	if m.fighter != nil {
		return *m.fighter, true
	}
	return
}

// FighterIDs returns the "fighter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FighterID instead. It exists only for internal usage by the builders.
func (m *FighterAliasMutation) FighterIDs() (ids []int) {
	if id := m.fighter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFighter resets all changes to the "fighter" edge.
func (m *FighterAliasMutation) ResetFighter() {
	m.fighter = nil
	m.clearedfighter = false
}

// Where appends a list predicates to the FighterAliasMutation builder.
func (m *FighterAliasMutation) Where(ps ...predicate.FighterAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FighterAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FighterAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FighterAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FighterAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FighterAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FighterAlias).
func (m *FighterAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FighterAliasMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, fighteralias.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fighteralias.FieldUpdatedAt)
	}
	if m.alias != nil {
		fields = append(fields, fighteralias.FieldAlias)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FighterAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fighteralias.FieldCreatedAt:
		return m.CreatedAt()
	case fighteralias.FieldUpdatedAt:
		return m.UpdatedAt()
	case fighteralias.FieldAlias:
		return m.Alias()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FighterAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fighteralias.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fighteralias.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fighteralias.FieldAlias:
		return m.OldAlias(ctx)
	}
	return nil, fmt.Errorf("unknown FighterAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fighteralias.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fighteralias.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fighteralias.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	}
	return fmt.Errorf("unknown FighterAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FighterAliasMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FighterAliasMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FighterAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FighterAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FighterAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FighterAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FighterAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FighterAliasMutation) ResetField(name string) error {
	switch name {
	case fighteralias.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fighteralias.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fighteralias.FieldAlias:
		m.ResetAlias()
		return nil
	}
	return fmt.Errorf("unknown FighterAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FighterAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fighter != nil {
		edges = append(edges, fighteralias.EdgeFighter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FighterAliasMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fighteralias.EdgeFighter:
		if id := m.fighter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FighterAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FighterAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FighterAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfighter {
		edges = append(edges, fighteralias.EdgeFighter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FighterAliasMutation) EdgeCleared(name string) bool {
	switch name {
	case fighteralias.EdgeFighter:
		return m.clearedfighter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FighterAliasMutation) ClearEdge(name string) error {
	switch name {
	case fighteralias.EdgeFighter:
		m.ClearFighter()
		return nil
	}
	return fmt.Errorf("unknown FighterAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FighterAliasMutation) ResetEdge(name string) error {
	switch name {
	case fighteralias.EdgeFighter:
		m.ResetFighter()
		return nil
	}
	return fmt.Errorf("unknown FighterAlias edge %s", name)
}

// FighterResultsMutation represents an operation that mutates the FighterResults nodes in the graph.
type FighterResultsMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	updated_at                    *time.Time
	significant_strikes_landed    *int
	addsignificant_strikes_landed *int
	takedowns                     *int
	addtakedowns                  *int
	knockdowns                    *int
	addknockdowns                 *int
	control_time_seconds          *int
	addcontrol_time_seconds       *int
	win_by_stoppage               *bool
	loss_by_stoppage              *bool
	missed_weight                 *bool
	clearedFields                 map[string]struct{}
	fighter                       *int
	clearedfighter                bool
	fight                         *int
	clearedfight                  bool
	done                          bool
	oldValue                      func(context.Context) (*FighterResults, error)
	predicates                    []predicate.FighterResults
}

var _ ent.Mutation = (*FighterResultsMutation)(nil)

// fighterresultsOption allows management of the mutation configuration using functional options.
type fighterresultsOption func(*FighterResultsMutation)

// newFighterResultsMutation creates new mutation for the FighterResults entity.
func newFighterResultsMutation(c config, op Op, opts ...fighterresultsOption) *FighterResultsMutation {
	m := &FighterResultsMutation{
		config:        c,
		op:            op,
		typ:           TypeFighterResults,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFighterResultsID sets the ID field of the mutation.
func withFighterResultsID(id int) fighterresultsOption {
	return func(m *FighterResultsMutation) {
		var (
			err   error
			once  sync.Once
			value *FighterResults
		)
		m.oldValue = func(ctx context.Context) (*FighterResults, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FighterResults.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFighterResults sets the old FighterResults of the mutation.
func withFighterResults(node *FighterResults) fighterresultsOption {
	return func(m *FighterResultsMutation) {
		m.oldValue = func(context.Context) (*FighterResults, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FighterResultsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FighterResultsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FighterResultsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FighterResultsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FighterResults.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FighterResultsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FighterResultsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FighterResultsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FighterResultsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FighterResultsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FighterResultsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFighterID sets the "fighter_id" field.
func (m *FighterResultsMutation) SetFighterID(i int) {
	m.fighter = &i
}

// FighterID returns the value of the "fighter_id" field in the mutation.
func (m *FighterResultsMutation) FighterID() (r int, exists bool) {
	v := m.fighter
	if v == nil {
		return
	}
	return *v, true
}

// OldFighterID returns the old "fighter_id" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldFighterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFighterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFighterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFighterID: %w", err)
	}
	return oldValue.FighterID, nil
}

// ResetFighterID resets all changes to the "fighter_id" field.
func (m *FighterResultsMutation) ResetFighterID() {
	m.fighter = nil
}

// SetFightID sets the "fight_id" field.
func (m *FighterResultsMutation) SetFightID(i int) {
	m.fight = &i
}

// FightID returns the value of the "fight_id" field in the mutation.
func (m *FighterResultsMutation) FightID() (r int, exists bool) {
	v := m.fight
	if v == nil {
		return
	}
	return *v, true
}

// OldFightID returns the old "fight_id" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldFightID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFightID: %w", err)
	}
	return oldValue.FightID, nil
}

// ResetFightID resets all changes to the "fight_id" field.
func (m *FighterResultsMutation) ResetFightID() {
	m.fight = nil
}

// SetSignificantStrikesLanded sets the "significant_strikes_landed" field.
func (m *FighterResultsMutation) SetSignificantStrikesLanded(i int) {
	m.significant_strikes_landed = &i
	m.addsignificant_strikes_landed = nil
}

// SignificantStrikesLanded returns the value of the "significant_strikes_landed" field in the mutation.
func (m *FighterResultsMutation) SignificantStrikesLanded() (r int, exists bool) {
	v := m.significant_strikes_landed
	if v == nil {
		return
	}
	return *v, true
}

// OldSignificantStrikesLanded returns the old "significant_strikes_landed" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldSignificantStrikesLanded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignificantStrikesLanded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignificantStrikesLanded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignificantStrikesLanded: %w", err)
	}
	return oldValue.SignificantStrikesLanded, nil
}

// AddSignificantStrikesLanded adds i to the "significant_strikes_landed" field.
func (m *FighterResultsMutation) AddSignificantStrikesLanded(i int) {
	if m.addsignificant_strikes_landed != nil {
		*m.addsignificant_strikes_landed += i
	} else {
		m.addsignificant_strikes_landed = &i
	}
}

// AddedSignificantStrikesLanded returns the value that was added to the "significant_strikes_landed" field in this mutation.
func (m *FighterResultsMutation) AddedSignificantStrikesLanded() (r int, exists bool) {
	v := m.addsignificant_strikes_landed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignificantStrikesLanded resets all changes to the "significant_strikes_landed" field.
func (m *FighterResultsMutation) ResetSignificantStrikesLanded() {
	m.significant_strikes_landed = nil
	m.addsignificant_strikes_landed = nil
}

// SetTakedowns sets the "takedowns" field.
func (m *FighterResultsMutation) SetTakedowns(i int) {
	m.takedowns = &i
	m.addtakedowns = nil
}

// Takedowns returns the value of the "takedowns" field in the mutation.
func (m *FighterResultsMutation) Takedowns() (r int, exists bool) {
	v := m.takedowns
	if v == nil {
		return
	}
	return *v, true
}

// OldTakedowns returns the old "takedowns" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldTakedowns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakedowns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakedowns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakedowns: %w", err)
	}
	return oldValue.Takedowns, nil
}

// AddTakedowns adds i to the "takedowns" field.
func (m *FighterResultsMutation) AddTakedowns(i int) {
	if m.addtakedowns != nil {
		*m.addtakedowns += i
	} else {
		m.addtakedowns = &i
	}
}

// AddedTakedowns returns the value that was added to the "takedowns" field in this mutation.
func (m *FighterResultsMutation) AddedTakedowns() (r int, exists bool) {
	v := m.addtakedowns
	if v == nil {
		return
	}
	return *v, true
}

// ResetTakedowns resets all changes to the "takedowns" field.
func (m *FighterResultsMutation) ResetTakedowns() {
	m.takedowns = nil
	m.addtakedowns = nil
}

// SetKnockdowns sets the "knockdowns" field.
func (m *FighterResultsMutation) SetKnockdowns(i int) {
	m.knockdowns = &i
	m.addknockdowns = nil
}

// Knockdowns returns the value of the "knockdowns" field in the mutation.
func (m *FighterResultsMutation) Knockdowns() (r int, exists bool) {
	v := m.knockdowns
	if v == nil {
		return
	}
	return *v, true
}

// OldKnockdowns returns the old "knockdowns" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldKnockdowns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKnockdowns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKnockdowns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKnockdowns: %w", err)
	}
	return oldValue.Knockdowns, nil
}

// AddKnockdowns adds i to the "knockdowns" field.
func (m *FighterResultsMutation) AddKnockdowns(i int) {
	if m.addknockdowns != nil {
		*m.addknockdowns += i
	} else {
		m.addknockdowns = &i
	}
}

// AddedKnockdowns returns the value that was added to the "knockdowns" field in this mutation.
func (m *FighterResultsMutation) AddedKnockdowns() (r int, exists bool) {
	v := m.addknockdowns
	if v == nil {
		return
	}
	return *v, true
}

// ResetKnockdowns resets all changes to the "knockdowns" field.
func (m *FighterResultsMutation) ResetKnockdowns() {
	m.knockdowns = nil
	m.addknockdowns = nil
}

// SetControlTimeSeconds sets the "control_time_seconds" field.
func (m *FighterResultsMutation) SetControlTimeSeconds(i int) {
	m.control_time_seconds = &i
	m.addcontrol_time_seconds = nil
}

// ControlTimeSeconds returns the value of the "control_time_seconds" field in the mutation.
func (m *FighterResultsMutation) ControlTimeSeconds() (r int, exists bool) {
	v := m.control_time_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldControlTimeSeconds returns the old "control_time_seconds" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldControlTimeSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlTimeSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlTimeSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlTimeSeconds: %w", err)
	}
	return oldValue.ControlTimeSeconds, nil
}

// AddControlTimeSeconds adds i to the "control_time_seconds" field.
func (m *FighterResultsMutation) AddControlTimeSeconds(i int) {
	if m.addcontrol_time_seconds != nil {
		*m.addcontrol_time_seconds += i
	} else {
		m.addcontrol_time_seconds = &i
	}
}

// AddedControlTimeSeconds returns the value that was added to the "control_time_seconds" field in this mutation.
func (m *FighterResultsMutation) AddedControlTimeSeconds() (r int, exists bool) {
	v := m.addcontrol_time_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ResetControlTimeSeconds resets all changes to the "control_time_seconds" field.
func (m *FighterResultsMutation) ResetControlTimeSeconds() {
	m.control_time_seconds = nil
	m.addcontrol_time_seconds = nil
}

// SetWinByStoppage sets the "win_by_stoppage" field.
func (m *FighterResultsMutation) SetWinByStoppage(b bool) {
	m.win_by_stoppage = &b
}

// WinByStoppage returns the value of the "win_by_stoppage" field in the mutation.
func (m *FighterResultsMutation) WinByStoppage() (r bool, exists bool) {
	v := m.win_by_stoppage
	if v == nil {
		return
	}
	return *v, true
}

// OldWinByStoppage returns the old "win_by_stoppage" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldWinByStoppage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinByStoppage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinByStoppage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinByStoppage: %w", err)
	}
	return oldValue.WinByStoppage, nil
}

// ResetWinByStoppage resets all changes to the "win_by_stoppage" field.
func (m *FighterResultsMutation) ResetWinByStoppage() {
	m.win_by_stoppage = nil
}

// SetLossByStoppage sets the "loss_by_stoppage" field.
func (m *FighterResultsMutation) SetLossByStoppage(b bool) {
	m.loss_by_stoppage = &b
}

// LossByStoppage returns the value of the "loss_by_stoppage" field in the mutation.
func (m *FighterResultsMutation) LossByStoppage() (r bool, exists bool) {
	v := m.loss_by_stoppage
	if v == nil {
		return
	}
	return *v, true
}

// OldLossByStoppage returns the old "loss_by_stoppage" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldLossByStoppage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossByStoppage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossByStoppage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossByStoppage: %w", err)
	}
	return oldValue.LossByStoppage, nil
}

// ResetLossByStoppage resets all changes to the "loss_by_stoppage" field.
func (m *FighterResultsMutation) ResetLossByStoppage() {
	m.loss_by_stoppage = nil
}

// SetMissedWeight sets the "missed_weight" field.
func (m *FighterResultsMutation) SetMissedWeight(b bool) {
	m.missed_weight = &b
}

// MissedWeight returns the value of the "missed_weight" field in the mutation.
func (m *FighterResultsMutation) MissedWeight() (r bool, exists bool) {
	v := m.missed_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMissedWeight returns the old "missed_weight" field's value of the FighterResults entity.
// If the FighterResults object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FighterResultsMutation) OldMissedWeight(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissedWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissedWeight: %w", err)
	}
	return oldValue.MissedWeight, nil
}

// ClearMissedWeight clears the value of the "missed_weight" field.
func (m *FighterResultsMutation) ClearMissedWeight() {
	m.missed_weight = nil
	m.clearedFields[fighterresults.FieldMissedWeight] = struct{}{}
}

// MissedWeightCleared returns if the "missed_weight" field was cleared in this mutation.
func (m *FighterResultsMutation) MissedWeightCleared() bool {
	_, ok := m.clearedFields[fighterresults.FieldMissedWeight]
	return ok
}

// ResetMissedWeight resets all changes to the "missed_weight" field.
func (m *FighterResultsMutation) ResetMissedWeight() {
	m.missed_weight = nil
	delete(m.clearedFields, fighterresults.FieldMissedWeight)
}

// ClearFighter clears the "fighter" edge to the Fighter entity.
func (m *FighterResultsMutation) ClearFighter() {
	m.clearedfighter = true
}

// FighterCleared reports if the "fighter" edge to the Fighter entity was cleared.
func (m *FighterResultsMutation) FighterCleared() bool {
	return m.clearedfighter
}

// FighterIDs returns the "fighter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FighterID instead. It exists only for internal usage by the builders.
func (m *FighterResultsMutation) FighterIDs() (ids []int) {
	if id := m.fighter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFighter resets all changes to the "fighter" edge.
func (m *FighterResultsMutation) ResetFighter() {
	m.fighter = nil
	m.clearedfighter = false
}

// ClearFight clears the "fight" edge to the Fight entity.
func (m *FighterResultsMutation) ClearFight() {
	m.clearedfight = true
}

// FightCleared reports if the "fight" edge to the Fight entity was cleared.
func (m *FighterResultsMutation) FightCleared() bool {
	return m.clearedfight
}

// FightIDs returns the "fight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FightID instead. It exists only for internal usage by the builders.
func (m *FighterResultsMutation) FightIDs() (ids []int) {
	if id := m.fight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFight resets all changes to the "fight" edge.
func (m *FighterResultsMutation) ResetFight() {
	m.fight = nil
	m.clearedfight = false
}

// Where appends a list predicates to the FighterResultsMutation builder.
func (m *FighterResultsMutation) Where(ps ...predicate.FighterResults) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FighterResultsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FighterResultsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FighterResults, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FighterResultsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FighterResultsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FighterResults).
func (m *FighterResultsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FighterResultsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, fighterresults.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fighterresults.FieldUpdatedAt)
	}
	if m.fighter != nil {
		fields = append(fields, fighterresults.FieldFighterID)
	}
	if m.fight != nil {
		fields = append(fields, fighterresults.FieldFightID)
	}
	if m.significant_strikes_landed != nil {
		fields = append(fields, fighterresults.FieldSignificantStrikesLanded)
	}
	if m.takedowns != nil {
		fields = append(fields, fighterresults.FieldTakedowns)
	}
	if m.knockdowns != nil {
		fields = append(fields, fighterresults.FieldKnockdowns)
	}
	if m.control_time_seconds != nil {
		fields = append(fields, fighterresults.FieldControlTimeSeconds)
	}
	if m.win_by_stoppage != nil {
		fields = append(fields, fighterresults.FieldWinByStoppage)
	}
	if m.loss_by_stoppage != nil {
		fields = append(fields, fighterresults.FieldLossByStoppage)
	}
	if m.missed_weight != nil {
		fields = append(fields, fighterresults.FieldMissedWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FighterResultsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fighterresults.FieldCreatedAt:
		return m.CreatedAt()
	case fighterresults.FieldUpdatedAt:
		return m.UpdatedAt()
	case fighterresults.FieldFighterID:
		return m.FighterID()
	case fighterresults.FieldFightID:
		return m.FightID()
	case fighterresults.FieldSignificantStrikesLanded:
		return m.SignificantStrikesLanded()
	case fighterresults.FieldTakedowns:
		return m.Takedowns()
	case fighterresults.FieldKnockdowns:
		return m.Knockdowns()
	case fighterresults.FieldControlTimeSeconds:
		return m.ControlTimeSeconds()
	case fighterresults.FieldWinByStoppage:
		return m.WinByStoppage()
	case fighterresults.FieldLossByStoppage:
		return m.LossByStoppage()
	case fighterresults.FieldMissedWeight:
		return m.MissedWeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FighterResultsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fighterresults.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fighterresults.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fighterresults.FieldFighterID:
		return m.OldFighterID(ctx)
	case fighterresults.FieldFightID:
		return m.OldFightID(ctx)
	case fighterresults.FieldSignificantStrikesLanded:
		return m.OldSignificantStrikesLanded(ctx)
	case fighterresults.FieldTakedowns:
		return m.OldTakedowns(ctx)
	case fighterresults.FieldKnockdowns:
		return m.OldKnockdowns(ctx)
	case fighterresults.FieldControlTimeSeconds:
		return m.OldControlTimeSeconds(ctx)
	case fighterresults.FieldWinByStoppage:
		return m.OldWinByStoppage(ctx)
	case fighterresults.FieldLossByStoppage:
		return m.OldLossByStoppage(ctx)
	case fighterresults.FieldMissedWeight:
		return m.OldMissedWeight(ctx)
	}
	return nil, fmt.Errorf("unknown FighterResults field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterResultsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fighterresults.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fighterresults.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fighterresults.FieldFighterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFighterID(v)
		return nil
	case fighterresults.FieldFightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFightID(v)
		return nil
	case fighterresults.FieldSignificantStrikesLanded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignificantStrikesLanded(v)
		return nil
	case fighterresults.FieldTakedowns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakedowns(v)
		return nil
	case fighterresults.FieldKnockdowns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKnockdowns(v)
		return nil
	case fighterresults.FieldControlTimeSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlTimeSeconds(v)
		return nil
	case fighterresults.FieldWinByStoppage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinByStoppage(v)
		return nil
	case fighterresults.FieldLossByStoppage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossByStoppage(v)
		return nil
	case fighterresults.FieldMissedWeight:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissedWeight(v)
		return nil
	}
	return fmt.Errorf("unknown FighterResults field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FighterResultsMutation) AddedFields() []string {
	var fields []string
	if m.addsignificant_strikes_landed != nil {
		fields = append(fields, fighterresults.FieldSignificantStrikesLanded)
	}
	if m.addtakedowns != nil {
		fields = append(fields, fighterresults.FieldTakedowns)
	}
	if m.addknockdowns != nil {
		fields = append(fields, fighterresults.FieldKnockdowns)
	}
	if m.addcontrol_time_seconds != nil {
		fields = append(fields, fighterresults.FieldControlTimeSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FighterResultsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fighterresults.FieldSignificantStrikesLanded:
		return m.AddedSignificantStrikesLanded()
	case fighterresults.FieldTakedowns:
		return m.AddedTakedowns()
	case fighterresults.FieldKnockdowns:
		return m.AddedKnockdowns()
	case fighterresults.FieldControlTimeSeconds:
		return m.AddedControlTimeSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FighterResultsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fighterresults.FieldSignificantStrikesLanded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignificantStrikesLanded(v)
		return nil
	case fighterresults.FieldTakedowns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTakedowns(v)
		return nil
	case fighterresults.FieldKnockdowns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKnockdowns(v)
		return nil
	case fighterresults.FieldControlTimeSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddControlTimeSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown FighterResults numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FighterResultsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fighterresults.FieldMissedWeight) {
		fields = append(fields, fighterresults.FieldMissedWeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FighterResultsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FighterResultsMutation) ClearField(name string) error {
	switch name {
	case fighterresults.FieldMissedWeight:
		m.ClearMissedWeight()
		return nil
	}
	return fmt.Errorf("unknown FighterResults nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FighterResultsMutation) ResetField(name string) error {
	switch name {
	case fighterresults.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fighterresults.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fighterresults.FieldFighterID:
		m.ResetFighterID()
		return nil
	case fighterresults.FieldFightID:
		m.ResetFightID()
		return nil
	case fighterresults.FieldSignificantStrikesLanded:
		m.ResetSignificantStrikesLanded()
		return nil
	case fighterresults.FieldTakedowns:
		m.ResetTakedowns()
		return nil
	case fighterresults.FieldKnockdowns:
		m.ResetKnockdowns()
		return nil
	case fighterresults.FieldControlTimeSeconds:
		m.ResetControlTimeSeconds()
		return nil
	case fighterresults.FieldWinByStoppage:
		m.ResetWinByStoppage()
		return nil
	case fighterresults.FieldLossByStoppage:
		m.ResetLossByStoppage()
		return nil
	case fighterresults.FieldMissedWeight:
		m.ResetMissedWeight()
		return nil
	}
	return fmt.Errorf("unknown FighterResults field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FighterResultsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.fighter != nil {
		edges = append(edges, fighterresults.EdgeFighter)
	}
	if m.fight != nil {
		edges = append(edges, fighterresults.EdgeFight)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FighterResultsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fighterresults.EdgeFighter:
		if id := m.fighter; id != nil {
			return []ent.Value{*id}
		}
	case fighterresults.EdgeFight:
		if id := m.fight; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FighterResultsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FighterResultsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FighterResultsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfighter {
		edges = append(edges, fighterresults.EdgeFighter)
	}
	if m.clearedfight {
		edges = append(edges, fighterresults.EdgeFight)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FighterResultsMutation) EdgeCleared(name string) bool {
	switch name {
	case fighterresults.EdgeFighter:
		return m.clearedfighter
	case fighterresults.EdgeFight:
		return m.clearedfight
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FighterResultsMutation) ClearEdge(name string) error {
	switch name {
	case fighterresults.EdgeFighter:
		m.ClearFighter()
		return nil
	case fighterresults.EdgeFight:
		m.ClearFight()
		return nil
	}
	return fmt.Errorf("unknown FighterResults unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FighterResultsMutation) ResetEdge(name string) error {
	switch name {
	case fighterresults.EdgeFighter:
		m.ResetFighter()
		return nil
	case fighterresults.EdgeFight:
		m.ResetFight()
		return nil
	}
	return fmt.Errorf("unknown FighterResults edge %s", name)
}

// UpcomingEventMutation represents an operation that mutates the UpcomingEvent nodes in the graph.
type UpcomingEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpcomingEvent, error)
	predicates    []predicate.UpcomingEvent
}

var _ ent.Mutation = (*UpcomingEventMutation)(nil)

// upcomingeventOption allows management of the mutation configuration using functional options.
type upcomingeventOption func(*UpcomingEventMutation)

// newUpcomingEventMutation creates new mutation for the UpcomingEvent entity.
func newUpcomingEventMutation(c config, op Op, opts ...upcomingeventOption) *UpcomingEventMutation {
	m := &UpcomingEventMutation{
		config:        c,
		op:            op,
		typ:           TypeUpcomingEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpcomingEventID sets the ID field of the mutation.
func withUpcomingEventID(id int) upcomingeventOption {
	return func(m *UpcomingEventMutation) {
		var (
			err   error
			once  sync.Once
			value *UpcomingEvent
		)
		m.oldValue = func(ctx context.Context) (*UpcomingEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpcomingEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpcomingEvent sets the old UpcomingEvent of the mutation.
func withUpcomingEvent(node *UpcomingEvent) upcomingeventOption {
	return func(m *UpcomingEventMutation) {
		m.oldValue = func(context.Context) (*UpcomingEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpcomingEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpcomingEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpcomingEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpcomingEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpcomingEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UpcomingEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpcomingEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpcomingEvent entity.
// If the UpcomingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpcomingEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpcomingEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpcomingEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpcomingEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpcomingEvent entity.
// If the UpcomingEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpcomingEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpcomingEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UpcomingEventMutation builder.
func (m *UpcomingEventMutation) Where(ps ...predicate.UpcomingEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpcomingEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpcomingEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpcomingEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpcomingEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpcomingEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpcomingEvent).
func (m *UpcomingEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpcomingEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, upcomingevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upcomingevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpcomingEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upcomingevent.FieldCreatedAt:
		return m.CreatedAt()
	case upcomingevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpcomingEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upcomingevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upcomingevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpcomingEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpcomingEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upcomingevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upcomingevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpcomingEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpcomingEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpcomingEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpcomingEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpcomingEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpcomingEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpcomingEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpcomingEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpcomingEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpcomingEventMutation) ResetField(name string) error {
	switch name {
	case upcomingevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upcomingevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpcomingEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpcomingEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpcomingEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpcomingEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpcomingEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpcomingEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpcomingEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpcomingEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpcomingEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpcomingEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpcomingEvent edge %s", name)
}

// UpcomingFightMutation represents an operation that mutates the UpcomingFight nodes in the graph.
type UpcomingFightMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UpcomingFight, error)
	predicates    []predicate.UpcomingFight
}

var _ ent.Mutation = (*UpcomingFightMutation)(nil)

// upcomingfightOption allows management of the mutation configuration using functional options.
type upcomingfightOption func(*UpcomingFightMutation)

// newUpcomingFightMutation creates new mutation for the UpcomingFight entity.
func newUpcomingFightMutation(c config, op Op, opts ...upcomingfightOption) *UpcomingFightMutation {
	m := &UpcomingFightMutation{
		config:        c,
		op:            op,
		typ:           TypeUpcomingFight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpcomingFightID sets the ID field of the mutation.
func withUpcomingFightID(id int) upcomingfightOption {
	return func(m *UpcomingFightMutation) {
		var (
			err   error
			once  sync.Once
			value *UpcomingFight
		)
		m.oldValue = func(ctx context.Context) (*UpcomingFight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpcomingFight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpcomingFight sets the old UpcomingFight of the mutation.
func withUpcomingFight(node *UpcomingFight) upcomingfightOption {
	return func(m *UpcomingFightMutation) {
		m.oldValue = func(context.Context) (*UpcomingFight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpcomingFightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpcomingFightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpcomingFightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpcomingFightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpcomingFight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UpcomingFightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpcomingFightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpcomingFight entity.
// If the UpcomingFight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpcomingFightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpcomingFightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UpcomingFightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UpcomingFightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UpcomingFight entity.
// If the UpcomingFight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpcomingFightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UpcomingFightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UpcomingFightMutation builder.
func (m *UpcomingFightMutation) Where(ps ...predicate.UpcomingFight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpcomingFightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpcomingFightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpcomingFight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpcomingFightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpcomingFightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpcomingFight).
func (m *UpcomingFightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpcomingFightMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, upcomingfight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, upcomingfight.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpcomingFightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upcomingfight.FieldCreatedAt:
		return m.CreatedAt()
	case upcomingfight.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpcomingFightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upcomingfight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upcomingfight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UpcomingFight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpcomingFightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upcomingfight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upcomingfight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UpcomingFight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpcomingFightMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpcomingFightMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpcomingFightMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UpcomingFight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpcomingFightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpcomingFightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpcomingFightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UpcomingFight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpcomingFightMutation) ResetField(name string) error {
	switch name {
	case upcomingfight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upcomingfight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UpcomingFight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpcomingFightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpcomingFightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpcomingFightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpcomingFightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpcomingFightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpcomingFightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpcomingFightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UpcomingFight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpcomingFightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UpcomingFight edge %s", name)
}
